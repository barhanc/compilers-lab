Grammar:

Rule 0     S' -> statementseq
Rule 1     statementseq -> statement
Rule 2     statementseq -> statement statementseq
Rule 3     statement -> { statementseq }
Rule 4     statement -> FOR ID = expr : expr statement
Rule 5     statement -> WHILE ( expr ) statement
Rule 6     statement -> IF ( expr ) statement ELSE statement  [precedence=nonassoc, level=7]
Rule 7     statement -> IF ( expr ) statement  [precedence=nonassoc, level=6]
Rule 8     statement -> ID [ exprseq ] IDIV expr ;
Rule 9     statement -> ID [ exprseq ] IMUL expr ;
Rule 10    statement -> ID [ exprseq ] ISUB expr ;
Rule 11    statement -> ID [ exprseq ] IADD expr ;
Rule 12    statement -> ID [ exprseq ] = expr ;
Rule 13    statement -> ID IDIV expr ;
Rule 14    statement -> ID IMUL expr ;
Rule 15    statement -> ID ISUB expr ;
Rule 16    statement -> ID IADD expr ;
Rule 17    statement -> ID = expr ;
Rule 18    statement -> CONTINUE ;
Rule 19    statement -> BREAK ;
Rule 20    statement -> RETURN exprseq ;
Rule 21    statement -> PRINT exprseq ;
Rule 22    expr -> array
Rule 23    expr -> expr [ exprseq ]
Rule 24    expr -> ZEROS ( expr )
Rule 25    expr -> ONES ( expr )
Rule 26    expr -> EYE ( expr )
Rule 27    expr -> STRING
Rule 28    expr -> FLOATNUM
Rule 29    expr -> INTNUM
Rule 30    expr -> ID
Rule 31    expr -> ( expr )
Rule 32    expr -> expr LE expr  [precedence=nonassoc, level=1]
Rule 33    expr -> expr LT expr  [precedence=nonassoc, level=1]
Rule 34    expr -> expr GE expr  [precedence=nonassoc, level=1]
Rule 35    expr -> expr GT expr  [precedence=nonassoc, level=1]
Rule 36    expr -> expr NE expr  [precedence=nonassoc, level=1]
Rule 37    expr -> expr EQ expr  [precedence=nonassoc, level=1]
Rule 38    expr -> expr DDIV expr  [precedence=left, level=3]
Rule 39    expr -> expr DMUL expr  [precedence=left, level=3]
Rule 40    expr -> expr DSUB expr  [precedence=left, level=2]
Rule 41    expr -> expr DADD expr  [precedence=left, level=2]
Rule 42    expr -> expr DIV expr  [precedence=left, level=3]
Rule 43    expr -> expr MUL expr  [precedence=left, level=3]
Rule 44    expr -> expr SUB expr  [precedence=left, level=2]
Rule 45    expr -> expr ADD expr  [precedence=left, level=2]
Rule 46    expr -> expr '  [precedence=left, level=5]
Rule 47    expr -> SUB expr  [precedence=right, level=4]
Rule 48    exprseq -> exprseq , expr
Rule 49    exprseq -> expr
Rule 50    array -> [ exprseq ]

Terminals, with rules where they appear:

'                    : 46
(                    : 5 6 7 24 25 26 31
)                    : 5 6 7 24 25 26 31
,                    : 48
:                    : 4
;                    : 8 9 10 11 12 13 14 15 16 17 18 19 20 21
=                    : 4 12 17
ADD                  : 45
BREAK                : 19
CONTINUE             : 18
DADD                 : 41
DDIV                 : 38
DIV                  : 42
DMUL                 : 39
DSUB                 : 40
ELSE                 : 6
EQ                   : 37
EYE                  : 26
FLOATNUM             : 28
FOR                  : 4
GE                   : 34
GT                   : 35
IADD                 : 11 16
ID                   : 4 8 9 10 11 12 13 14 15 16 17 30
IDIV                 : 8 13
IF                   : 6 7
IMUL                 : 9 14
INTNUM               : 29
ISUB                 : 10 15
LE                   : 32
LT                   : 33
MUL                  : 43
NE                   : 36
ONES                 : 25
PRINT                : 21
RETURN               : 20
STRING               : 27
SUB                  : 44 47
WHILE                : 5
ZEROS                : 24
[                    : 8 9 10 11 12 23 50
]                    : 8 9 10 11 12 23 50
error                : 
{                    : 3
}                    : 3

Nonterminals, with rules where they appear:

array                : 22
expr                 : 4 4 5 6 7 8 9 10 11 12 13 14 15 16 17 23 24 25 26 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 47 48 49
exprseq              : 8 9 10 11 12 20 21 23 48 50
statement            : 1 2 4 5 6 6 7
statementseq         : 2 3 0


state 0

    (0) S' -> . statementseq
    (1) statementseq -> . statement
    (2) statementseq -> . statement statementseq
    (3) statement -> . { statementseq }
    (4) statement -> . FOR ID = expr : expr statement
    (5) statement -> . WHILE ( expr ) statement
    (6) statement -> . IF ( expr ) statement ELSE statement
    (7) statement -> . IF ( expr ) statement
    (8) statement -> . ID [ exprseq ] IDIV expr ;
    (9) statement -> . ID [ exprseq ] IMUL expr ;
    (10) statement -> . ID [ exprseq ] ISUB expr ;
    (11) statement -> . ID [ exprseq ] IADD expr ;
    (12) statement -> . ID [ exprseq ] = expr ;
    (13) statement -> . ID IDIV expr ;
    (14) statement -> . ID IMUL expr ;
    (15) statement -> . ID ISUB expr ;
    (16) statement -> . ID IADD expr ;
    (17) statement -> . ID = expr ;
    (18) statement -> . CONTINUE ;
    (19) statement -> . BREAK ;
    (20) statement -> . RETURN exprseq ;
    (21) statement -> . PRINT exprseq ;
    {               shift and go to state 3
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 7
    ID              shift and go to state 5
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    RETURN          shift and go to state 10
    PRINT           shift and go to state 11

    statementseq                   shift and go to state 1
    statement                      shift and go to state 2

state 1

    (0) S' -> statementseq .


state 2

    (1) statementseq -> statement .
    (2) statementseq -> statement . statementseq
    (1) statementseq -> . statement
    (2) statementseq -> . statement statementseq
    (3) statement -> . { statementseq }
    (4) statement -> . FOR ID = expr : expr statement
    (5) statement -> . WHILE ( expr ) statement
    (6) statement -> . IF ( expr ) statement ELSE statement
    (7) statement -> . IF ( expr ) statement
    (8) statement -> . ID [ exprseq ] IDIV expr ;
    (9) statement -> . ID [ exprseq ] IMUL expr ;
    (10) statement -> . ID [ exprseq ] ISUB expr ;
    (11) statement -> . ID [ exprseq ] IADD expr ;
    (12) statement -> . ID [ exprseq ] = expr ;
    (13) statement -> . ID IDIV expr ;
    (14) statement -> . ID IMUL expr ;
    (15) statement -> . ID ISUB expr ;
    (16) statement -> . ID IADD expr ;
    (17) statement -> . ID = expr ;
    (18) statement -> . CONTINUE ;
    (19) statement -> . BREAK ;
    (20) statement -> . RETURN exprseq ;
    (21) statement -> . PRINT exprseq ;
    $end            reduce using rule 1 (statementseq -> statement .)
    }               reduce using rule 1 (statementseq -> statement .)
    {               shift and go to state 3
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 7
    ID              shift and go to state 5
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    RETURN          shift and go to state 10
    PRINT           shift and go to state 11

    statement                      shift and go to state 2
    statementseq                   shift and go to state 12

state 3

    (3) statement -> { . statementseq }
    (1) statementseq -> . statement
    (2) statementseq -> . statement statementseq
    (3) statement -> . { statementseq }
    (4) statement -> . FOR ID = expr : expr statement
    (5) statement -> . WHILE ( expr ) statement
    (6) statement -> . IF ( expr ) statement ELSE statement
    (7) statement -> . IF ( expr ) statement
    (8) statement -> . ID [ exprseq ] IDIV expr ;
    (9) statement -> . ID [ exprseq ] IMUL expr ;
    (10) statement -> . ID [ exprseq ] ISUB expr ;
    (11) statement -> . ID [ exprseq ] IADD expr ;
    (12) statement -> . ID [ exprseq ] = expr ;
    (13) statement -> . ID IDIV expr ;
    (14) statement -> . ID IMUL expr ;
    (15) statement -> . ID ISUB expr ;
    (16) statement -> . ID IADD expr ;
    (17) statement -> . ID = expr ;
    (18) statement -> . CONTINUE ;
    (19) statement -> . BREAK ;
    (20) statement -> . RETURN exprseq ;
    (21) statement -> . PRINT exprseq ;
    {               shift and go to state 3
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 7
    ID              shift and go to state 5
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    RETURN          shift and go to state 10
    PRINT           shift and go to state 11

    statementseq                   shift and go to state 13
    statement                      shift and go to state 2

state 4

    (4) statement -> FOR . ID = expr : expr statement
    ID              shift and go to state 14


state 5

    (8) statement -> ID . [ exprseq ] IDIV expr ;
    (9) statement -> ID . [ exprseq ] IMUL expr ;
    (10) statement -> ID . [ exprseq ] ISUB expr ;
    (11) statement -> ID . [ exprseq ] IADD expr ;
    (12) statement -> ID . [ exprseq ] = expr ;
    (13) statement -> ID . IDIV expr ;
    (14) statement -> ID . IMUL expr ;
    (15) statement -> ID . ISUB expr ;
    (16) statement -> ID . IADD expr ;
    (17) statement -> ID . = expr ;
    [               shift and go to state 15
    IDIV            shift and go to state 16
    IMUL            shift and go to state 17
    ISUB            shift and go to state 18
    IADD            shift and go to state 19
    =               shift and go to state 20


state 6

    (5) statement -> WHILE . ( expr ) statement
    (               shift and go to state 21


state 7

    (6) statement -> IF . ( expr ) statement ELSE statement
    (7) statement -> IF . ( expr ) statement
    (               shift and go to state 22


state 8

    (18) statement -> CONTINUE . ;
    ;               shift and go to state 23


state 9

    (19) statement -> BREAK . ;
    ;               shift and go to state 24


state 10

    (20) statement -> RETURN . exprseq ;
    (48) exprseq -> . exprseq , expr
    (49) exprseq -> . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    exprseq                        shift and go to state 25
    expr                           shift and go to state 26
    array                          shift and go to state 27

state 11

    (21) statement -> PRINT . exprseq ;
    (48) exprseq -> . exprseq , expr
    (49) exprseq -> . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    exprseq                        shift and go to state 38
    expr                           shift and go to state 26
    array                          shift and go to state 27

state 12

    (2) statementseq -> statement statementseq .
    $end            reduce using rule 2 (statementseq -> statement statementseq .)
    }               reduce using rule 2 (statementseq -> statement statementseq .)


state 13

    (3) statement -> { statementseq . }
    }               shift and go to state 39


state 14

    (4) statement -> FOR ID . = expr : expr statement
    =               shift and go to state 40


state 15

    (8) statement -> ID [ . exprseq ] IDIV expr ;
    (9) statement -> ID [ . exprseq ] IMUL expr ;
    (10) statement -> ID [ . exprseq ] ISUB expr ;
    (11) statement -> ID [ . exprseq ] IADD expr ;
    (12) statement -> ID [ . exprseq ] = expr ;
    (48) exprseq -> . exprseq , expr
    (49) exprseq -> . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    exprseq                        shift and go to state 41
    expr                           shift and go to state 26
    array                          shift and go to state 27

state 16

    (13) statement -> ID IDIV . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 42
    array                          shift and go to state 27

state 17

    (14) statement -> ID IMUL . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 43
    array                          shift and go to state 27

state 18

    (15) statement -> ID ISUB . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 44
    array                          shift and go to state 27

state 19

    (16) statement -> ID IADD . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 45
    array                          shift and go to state 27

state 20

    (17) statement -> ID = . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 46
    array                          shift and go to state 27

state 21

    (5) statement -> WHILE ( . expr ) statement
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 47
    array                          shift and go to state 27

state 22

    (6) statement -> IF ( . expr ) statement ELSE statement
    (7) statement -> IF ( . expr ) statement
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 48
    array                          shift and go to state 27

state 23

    (18) statement -> CONTINUE ; .
    {               reduce using rule 18 (statement -> CONTINUE ; .)
    FOR             reduce using rule 18 (statement -> CONTINUE ; .)
    WHILE           reduce using rule 18 (statement -> CONTINUE ; .)
    IF              reduce using rule 18 (statement -> CONTINUE ; .)
    ID              reduce using rule 18 (statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 18 (statement -> CONTINUE ; .)
    BREAK           reduce using rule 18 (statement -> CONTINUE ; .)
    RETURN          reduce using rule 18 (statement -> CONTINUE ; .)
    PRINT           reduce using rule 18 (statement -> CONTINUE ; .)
    $end            reduce using rule 18 (statement -> CONTINUE ; .)
    }               reduce using rule 18 (statement -> CONTINUE ; .)
    ELSE            reduce using rule 18 (statement -> CONTINUE ; .)


state 24

    (19) statement -> BREAK ; .
    {               reduce using rule 19 (statement -> BREAK ; .)
    FOR             reduce using rule 19 (statement -> BREAK ; .)
    WHILE           reduce using rule 19 (statement -> BREAK ; .)
    IF              reduce using rule 19 (statement -> BREAK ; .)
    ID              reduce using rule 19 (statement -> BREAK ; .)
    CONTINUE        reduce using rule 19 (statement -> BREAK ; .)
    BREAK           reduce using rule 19 (statement -> BREAK ; .)
    RETURN          reduce using rule 19 (statement -> BREAK ; .)
    PRINT           reduce using rule 19 (statement -> BREAK ; .)
    $end            reduce using rule 19 (statement -> BREAK ; .)
    }               reduce using rule 19 (statement -> BREAK ; .)
    ELSE            reduce using rule 19 (statement -> BREAK ; .)


state 25

    (20) statement -> RETURN exprseq . ;
    (48) exprseq -> exprseq . , expr
    ;               shift and go to state 49
    ,               shift and go to state 50


state 26

    (49) exprseq -> expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               reduce using rule 49 (exprseq -> expr .)
    ,               reduce using rule 49 (exprseq -> expr .)
    ]               reduce using rule 49 (exprseq -> expr .)
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 27

    (22) expr -> array .
    [               reduce using rule 22 (expr -> array .)
    LE              reduce using rule 22 (expr -> array .)
    LT              reduce using rule 22 (expr -> array .)
    GE              reduce using rule 22 (expr -> array .)
    GT              reduce using rule 22 (expr -> array .)
    NE              reduce using rule 22 (expr -> array .)
    EQ              reduce using rule 22 (expr -> array .)
    DDIV            reduce using rule 22 (expr -> array .)
    DMUL            reduce using rule 22 (expr -> array .)
    DSUB            reduce using rule 22 (expr -> array .)
    DADD            reduce using rule 22 (expr -> array .)
    DIV             reduce using rule 22 (expr -> array .)
    MUL             reduce using rule 22 (expr -> array .)
    SUB             reduce using rule 22 (expr -> array .)
    ADD             reduce using rule 22 (expr -> array .)
    '               reduce using rule 22 (expr -> array .)
    ;               reduce using rule 22 (expr -> array .)
    ,               reduce using rule 22 (expr -> array .)
    ]               reduce using rule 22 (expr -> array .)
    )               reduce using rule 22 (expr -> array .)
    :               reduce using rule 22 (expr -> array .)
    {               reduce using rule 22 (expr -> array .)
    FOR             reduce using rule 22 (expr -> array .)
    WHILE           reduce using rule 22 (expr -> array .)
    IF              reduce using rule 22 (expr -> array .)
    ID              reduce using rule 22 (expr -> array .)
    CONTINUE        reduce using rule 22 (expr -> array .)
    BREAK           reduce using rule 22 (expr -> array .)
    RETURN          reduce using rule 22 (expr -> array .)
    PRINT           reduce using rule 22 (expr -> array .)


state 28

    (50) array -> [ . exprseq ]
    (48) exprseq -> . exprseq , expr
    (49) exprseq -> . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    exprseq                        shift and go to state 67
    expr                           shift and go to state 26
    array                          shift and go to state 27

state 29

    (24) expr -> ZEROS . ( expr )
    (               shift and go to state 68


state 30

    (31) expr -> ( . expr )
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 69
    array                          shift and go to state 27

state 31

    (25) expr -> ONES . ( expr )
    (               shift and go to state 70


state 32

    (26) expr -> EYE . ( expr )
    (               shift and go to state 71


state 33

    (27) expr -> STRING .
    [               reduce using rule 27 (expr -> STRING .)
    LE              reduce using rule 27 (expr -> STRING .)
    LT              reduce using rule 27 (expr -> STRING .)
    GE              reduce using rule 27 (expr -> STRING .)
    GT              reduce using rule 27 (expr -> STRING .)
    NE              reduce using rule 27 (expr -> STRING .)
    EQ              reduce using rule 27 (expr -> STRING .)
    DDIV            reduce using rule 27 (expr -> STRING .)
    DMUL            reduce using rule 27 (expr -> STRING .)
    DSUB            reduce using rule 27 (expr -> STRING .)
    DADD            reduce using rule 27 (expr -> STRING .)
    DIV             reduce using rule 27 (expr -> STRING .)
    MUL             reduce using rule 27 (expr -> STRING .)
    SUB             reduce using rule 27 (expr -> STRING .)
    ADD             reduce using rule 27 (expr -> STRING .)
    '               reduce using rule 27 (expr -> STRING .)
    ;               reduce using rule 27 (expr -> STRING .)
    ,               reduce using rule 27 (expr -> STRING .)
    ]               reduce using rule 27 (expr -> STRING .)
    )               reduce using rule 27 (expr -> STRING .)
    :               reduce using rule 27 (expr -> STRING .)
    {               reduce using rule 27 (expr -> STRING .)
    FOR             reduce using rule 27 (expr -> STRING .)
    WHILE           reduce using rule 27 (expr -> STRING .)
    IF              reduce using rule 27 (expr -> STRING .)
    ID              reduce using rule 27 (expr -> STRING .)
    CONTINUE        reduce using rule 27 (expr -> STRING .)
    BREAK           reduce using rule 27 (expr -> STRING .)
    RETURN          reduce using rule 27 (expr -> STRING .)
    PRINT           reduce using rule 27 (expr -> STRING .)


state 34

    (28) expr -> FLOATNUM .
    [               reduce using rule 28 (expr -> FLOATNUM .)
    LE              reduce using rule 28 (expr -> FLOATNUM .)
    LT              reduce using rule 28 (expr -> FLOATNUM .)
    GE              reduce using rule 28 (expr -> FLOATNUM .)
    GT              reduce using rule 28 (expr -> FLOATNUM .)
    NE              reduce using rule 28 (expr -> FLOATNUM .)
    EQ              reduce using rule 28 (expr -> FLOATNUM .)
    DDIV            reduce using rule 28 (expr -> FLOATNUM .)
    DMUL            reduce using rule 28 (expr -> FLOATNUM .)
    DSUB            reduce using rule 28 (expr -> FLOATNUM .)
    DADD            reduce using rule 28 (expr -> FLOATNUM .)
    DIV             reduce using rule 28 (expr -> FLOATNUM .)
    MUL             reduce using rule 28 (expr -> FLOATNUM .)
    SUB             reduce using rule 28 (expr -> FLOATNUM .)
    ADD             reduce using rule 28 (expr -> FLOATNUM .)
    '               reduce using rule 28 (expr -> FLOATNUM .)
    ;               reduce using rule 28 (expr -> FLOATNUM .)
    ,               reduce using rule 28 (expr -> FLOATNUM .)
    ]               reduce using rule 28 (expr -> FLOATNUM .)
    )               reduce using rule 28 (expr -> FLOATNUM .)
    :               reduce using rule 28 (expr -> FLOATNUM .)
    {               reduce using rule 28 (expr -> FLOATNUM .)
    FOR             reduce using rule 28 (expr -> FLOATNUM .)
    WHILE           reduce using rule 28 (expr -> FLOATNUM .)
    IF              reduce using rule 28 (expr -> FLOATNUM .)
    ID              reduce using rule 28 (expr -> FLOATNUM .)
    CONTINUE        reduce using rule 28 (expr -> FLOATNUM .)
    BREAK           reduce using rule 28 (expr -> FLOATNUM .)
    RETURN          reduce using rule 28 (expr -> FLOATNUM .)
    PRINT           reduce using rule 28 (expr -> FLOATNUM .)


state 35

    (29) expr -> INTNUM .
    [               reduce using rule 29 (expr -> INTNUM .)
    LE              reduce using rule 29 (expr -> INTNUM .)
    LT              reduce using rule 29 (expr -> INTNUM .)
    GE              reduce using rule 29 (expr -> INTNUM .)
    GT              reduce using rule 29 (expr -> INTNUM .)
    NE              reduce using rule 29 (expr -> INTNUM .)
    EQ              reduce using rule 29 (expr -> INTNUM .)
    DDIV            reduce using rule 29 (expr -> INTNUM .)
    DMUL            reduce using rule 29 (expr -> INTNUM .)
    DSUB            reduce using rule 29 (expr -> INTNUM .)
    DADD            reduce using rule 29 (expr -> INTNUM .)
    DIV             reduce using rule 29 (expr -> INTNUM .)
    MUL             reduce using rule 29 (expr -> INTNUM .)
    SUB             reduce using rule 29 (expr -> INTNUM .)
    ADD             reduce using rule 29 (expr -> INTNUM .)
    '               reduce using rule 29 (expr -> INTNUM .)
    ;               reduce using rule 29 (expr -> INTNUM .)
    ,               reduce using rule 29 (expr -> INTNUM .)
    ]               reduce using rule 29 (expr -> INTNUM .)
    )               reduce using rule 29 (expr -> INTNUM .)
    :               reduce using rule 29 (expr -> INTNUM .)
    {               reduce using rule 29 (expr -> INTNUM .)
    FOR             reduce using rule 29 (expr -> INTNUM .)
    WHILE           reduce using rule 29 (expr -> INTNUM .)
    IF              reduce using rule 29 (expr -> INTNUM .)
    ID              reduce using rule 29 (expr -> INTNUM .)
    CONTINUE        reduce using rule 29 (expr -> INTNUM .)
    BREAK           reduce using rule 29 (expr -> INTNUM .)
    RETURN          reduce using rule 29 (expr -> INTNUM .)
    PRINT           reduce using rule 29 (expr -> INTNUM .)


state 36

    (30) expr -> ID .
    [               reduce using rule 30 (expr -> ID .)
    LE              reduce using rule 30 (expr -> ID .)
    LT              reduce using rule 30 (expr -> ID .)
    GE              reduce using rule 30 (expr -> ID .)
    GT              reduce using rule 30 (expr -> ID .)
    NE              reduce using rule 30 (expr -> ID .)
    EQ              reduce using rule 30 (expr -> ID .)
    DDIV            reduce using rule 30 (expr -> ID .)
    DMUL            reduce using rule 30 (expr -> ID .)
    DSUB            reduce using rule 30 (expr -> ID .)
    DADD            reduce using rule 30 (expr -> ID .)
    DIV             reduce using rule 30 (expr -> ID .)
    MUL             reduce using rule 30 (expr -> ID .)
    SUB             reduce using rule 30 (expr -> ID .)
    ADD             reduce using rule 30 (expr -> ID .)
    '               reduce using rule 30 (expr -> ID .)
    ;               reduce using rule 30 (expr -> ID .)
    ,               reduce using rule 30 (expr -> ID .)
    ]               reduce using rule 30 (expr -> ID .)
    )               reduce using rule 30 (expr -> ID .)
    :               reduce using rule 30 (expr -> ID .)
    {               reduce using rule 30 (expr -> ID .)
    FOR             reduce using rule 30 (expr -> ID .)
    WHILE           reduce using rule 30 (expr -> ID .)
    IF              reduce using rule 30 (expr -> ID .)
    ID              reduce using rule 30 (expr -> ID .)
    CONTINUE        reduce using rule 30 (expr -> ID .)
    BREAK           reduce using rule 30 (expr -> ID .)
    RETURN          reduce using rule 30 (expr -> ID .)
    PRINT           reduce using rule 30 (expr -> ID .)


state 37

    (47) expr -> SUB . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 72
    array                          shift and go to state 27

state 38

    (21) statement -> PRINT exprseq . ;
    (48) exprseq -> exprseq . , expr
    ;               shift and go to state 73
    ,               shift and go to state 50


state 39

    (3) statement -> { statementseq } .
    {               reduce using rule 3 (statement -> { statementseq } .)
    FOR             reduce using rule 3 (statement -> { statementseq } .)
    WHILE           reduce using rule 3 (statement -> { statementseq } .)
    IF              reduce using rule 3 (statement -> { statementseq } .)
    ID              reduce using rule 3 (statement -> { statementseq } .)
    CONTINUE        reduce using rule 3 (statement -> { statementseq } .)
    BREAK           reduce using rule 3 (statement -> { statementseq } .)
    RETURN          reduce using rule 3 (statement -> { statementseq } .)
    PRINT           reduce using rule 3 (statement -> { statementseq } .)
    $end            reduce using rule 3 (statement -> { statementseq } .)
    }               reduce using rule 3 (statement -> { statementseq } .)
    ELSE            reduce using rule 3 (statement -> { statementseq } .)


state 40

    (4) statement -> FOR ID = . expr : expr statement
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 74
    array                          shift and go to state 27

state 41

    (8) statement -> ID [ exprseq . ] IDIV expr ;
    (9) statement -> ID [ exprseq . ] IMUL expr ;
    (10) statement -> ID [ exprseq . ] ISUB expr ;
    (11) statement -> ID [ exprseq . ] IADD expr ;
    (12) statement -> ID [ exprseq . ] = expr ;
    (48) exprseq -> exprseq . , expr
    ]               shift and go to state 75
    ,               shift and go to state 50


state 42

    (13) statement -> ID IDIV expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 76
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 43

    (14) statement -> ID IMUL expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 77
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 44

    (15) statement -> ID ISUB expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 78
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 45

    (16) statement -> ID IADD expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 79
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 46

    (17) statement -> ID = expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 80
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 47

    (5) statement -> WHILE ( expr . ) statement
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    )               shift and go to state 81
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 48

    (6) statement -> IF ( expr . ) statement ELSE statement
    (7) statement -> IF ( expr . ) statement
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    )               shift and go to state 82
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 49

    (20) statement -> RETURN exprseq ; .
    {               reduce using rule 20 (statement -> RETURN exprseq ; .)
    FOR             reduce using rule 20 (statement -> RETURN exprseq ; .)
    WHILE           reduce using rule 20 (statement -> RETURN exprseq ; .)
    IF              reduce using rule 20 (statement -> RETURN exprseq ; .)
    ID              reduce using rule 20 (statement -> RETURN exprseq ; .)
    CONTINUE        reduce using rule 20 (statement -> RETURN exprseq ; .)
    BREAK           reduce using rule 20 (statement -> RETURN exprseq ; .)
    RETURN          reduce using rule 20 (statement -> RETURN exprseq ; .)
    PRINT           reduce using rule 20 (statement -> RETURN exprseq ; .)
    $end            reduce using rule 20 (statement -> RETURN exprseq ; .)
    }               reduce using rule 20 (statement -> RETURN exprseq ; .)
    ELSE            reduce using rule 20 (statement -> RETURN exprseq ; .)


state 50

    (48) exprseq -> exprseq , . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 83
    array                          shift and go to state 27

state 51

    (23) expr -> expr [ . exprseq ]
    (48) exprseq -> . exprseq , expr
    (49) exprseq -> . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 26
    exprseq                        shift and go to state 84
    array                          shift and go to state 27

state 52

    (32) expr -> expr LE . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 85
    array                          shift and go to state 27

state 53

    (33) expr -> expr LT . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 86
    array                          shift and go to state 27

state 54

    (34) expr -> expr GE . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 87
    array                          shift and go to state 27

state 55

    (35) expr -> expr GT . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 88
    array                          shift and go to state 27

state 56

    (36) expr -> expr NE . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 89
    array                          shift and go to state 27

state 57

    (37) expr -> expr EQ . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 90
    array                          shift and go to state 27

state 58

    (38) expr -> expr DDIV . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 91
    array                          shift and go to state 27

state 59

    (39) expr -> expr DMUL . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 92
    array                          shift and go to state 27

state 60

    (40) expr -> expr DSUB . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 93
    array                          shift and go to state 27

state 61

    (41) expr -> expr DADD . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 94
    array                          shift and go to state 27

state 62

    (42) expr -> expr DIV . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 95
    array                          shift and go to state 27

state 63

    (43) expr -> expr MUL . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 96
    array                          shift and go to state 27

state 64

    (44) expr -> expr SUB . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 97
    array                          shift and go to state 27

state 65

    (45) expr -> expr ADD . expr
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 98
    array                          shift and go to state 27

state 66

    (46) expr -> expr ' .
    [               reduce using rule 46 (expr -> expr ' .)
    LE              reduce using rule 46 (expr -> expr ' .)
    LT              reduce using rule 46 (expr -> expr ' .)
    GE              reduce using rule 46 (expr -> expr ' .)
    GT              reduce using rule 46 (expr -> expr ' .)
    NE              reduce using rule 46 (expr -> expr ' .)
    EQ              reduce using rule 46 (expr -> expr ' .)
    DDIV            reduce using rule 46 (expr -> expr ' .)
    DMUL            reduce using rule 46 (expr -> expr ' .)
    DSUB            reduce using rule 46 (expr -> expr ' .)
    DADD            reduce using rule 46 (expr -> expr ' .)
    DIV             reduce using rule 46 (expr -> expr ' .)
    MUL             reduce using rule 46 (expr -> expr ' .)
    SUB             reduce using rule 46 (expr -> expr ' .)
    ADD             reduce using rule 46 (expr -> expr ' .)
    '               reduce using rule 46 (expr -> expr ' .)
    ;               reduce using rule 46 (expr -> expr ' .)
    ,               reduce using rule 46 (expr -> expr ' .)
    ]               reduce using rule 46 (expr -> expr ' .)
    )               reduce using rule 46 (expr -> expr ' .)
    :               reduce using rule 46 (expr -> expr ' .)
    {               reduce using rule 46 (expr -> expr ' .)
    FOR             reduce using rule 46 (expr -> expr ' .)
    WHILE           reduce using rule 46 (expr -> expr ' .)
    IF              reduce using rule 46 (expr -> expr ' .)
    ID              reduce using rule 46 (expr -> expr ' .)
    CONTINUE        reduce using rule 46 (expr -> expr ' .)
    BREAK           reduce using rule 46 (expr -> expr ' .)
    RETURN          reduce using rule 46 (expr -> expr ' .)
    PRINT           reduce using rule 46 (expr -> expr ' .)


state 67

    (50) array -> [ exprseq . ]
    (48) exprseq -> exprseq . , expr
    ]               shift and go to state 99
    ,               shift and go to state 50


state 68

    (24) expr -> ZEROS ( . expr )
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 100
    array                          shift and go to state 27

state 69

    (31) expr -> ( expr . )
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    )               shift and go to state 101
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 70

    (25) expr -> ONES ( . expr )
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 102
    array                          shift and go to state 27

state 71

    (26) expr -> EYE ( . expr )
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 103
    array                          shift and go to state 27

state 72

    (47) expr -> SUB expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 47 (expr -> SUB expr .)
    LE              reduce using rule 47 (expr -> SUB expr .)
    LT              reduce using rule 47 (expr -> SUB expr .)
    GE              reduce using rule 47 (expr -> SUB expr .)
    GT              reduce using rule 47 (expr -> SUB expr .)
    NE              reduce using rule 47 (expr -> SUB expr .)
    EQ              reduce using rule 47 (expr -> SUB expr .)
    DDIV            reduce using rule 47 (expr -> SUB expr .)
    DMUL            reduce using rule 47 (expr -> SUB expr .)
    DSUB            reduce using rule 47 (expr -> SUB expr .)
    DADD            reduce using rule 47 (expr -> SUB expr .)
    DIV             reduce using rule 47 (expr -> SUB expr .)
    MUL             reduce using rule 47 (expr -> SUB expr .)
    SUB             reduce using rule 47 (expr -> SUB expr .)
    ADD             reduce using rule 47 (expr -> SUB expr .)
    ;               reduce using rule 47 (expr -> SUB expr .)
    ,               reduce using rule 47 (expr -> SUB expr .)
    ]               reduce using rule 47 (expr -> SUB expr .)
    )               reduce using rule 47 (expr -> SUB expr .)
    :               reduce using rule 47 (expr -> SUB expr .)
    {               reduce using rule 47 (expr -> SUB expr .)
    FOR             reduce using rule 47 (expr -> SUB expr .)
    WHILE           reduce using rule 47 (expr -> SUB expr .)
    IF              reduce using rule 47 (expr -> SUB expr .)
    ID              reduce using rule 47 (expr -> SUB expr .)
    CONTINUE        reduce using rule 47 (expr -> SUB expr .)
    BREAK           reduce using rule 47 (expr -> SUB expr .)
    RETURN          reduce using rule 47 (expr -> SUB expr .)
    PRINT           reduce using rule 47 (expr -> SUB expr .)
    '               shift and go to state 66


state 73

    (21) statement -> PRINT exprseq ; .
    {               reduce using rule 21 (statement -> PRINT exprseq ; .)
    FOR             reduce using rule 21 (statement -> PRINT exprseq ; .)
    WHILE           reduce using rule 21 (statement -> PRINT exprseq ; .)
    IF              reduce using rule 21 (statement -> PRINT exprseq ; .)
    ID              reduce using rule 21 (statement -> PRINT exprseq ; .)
    CONTINUE        reduce using rule 21 (statement -> PRINT exprseq ; .)
    BREAK           reduce using rule 21 (statement -> PRINT exprseq ; .)
    RETURN          reduce using rule 21 (statement -> PRINT exprseq ; .)
    PRINT           reduce using rule 21 (statement -> PRINT exprseq ; .)
    $end            reduce using rule 21 (statement -> PRINT exprseq ; .)
    }               reduce using rule 21 (statement -> PRINT exprseq ; .)
    ELSE            reduce using rule 21 (statement -> PRINT exprseq ; .)


state 74

    (4) statement -> FOR ID = expr . : expr statement
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    :               shift and go to state 104
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 75

    (8) statement -> ID [ exprseq ] . IDIV expr ;
    (9) statement -> ID [ exprseq ] . IMUL expr ;
    (10) statement -> ID [ exprseq ] . ISUB expr ;
    (11) statement -> ID [ exprseq ] . IADD expr ;
    (12) statement -> ID [ exprseq ] . = expr ;
    IDIV            shift and go to state 105
    IMUL            shift and go to state 106
    ISUB            shift and go to state 107
    IADD            shift and go to state 108
    =               shift and go to state 109


state 76

    (13) statement -> ID IDIV expr ; .
    {               reduce using rule 13 (statement -> ID IDIV expr ; .)
    FOR             reduce using rule 13 (statement -> ID IDIV expr ; .)
    WHILE           reduce using rule 13 (statement -> ID IDIV expr ; .)
    IF              reduce using rule 13 (statement -> ID IDIV expr ; .)
    ID              reduce using rule 13 (statement -> ID IDIV expr ; .)
    CONTINUE        reduce using rule 13 (statement -> ID IDIV expr ; .)
    BREAK           reduce using rule 13 (statement -> ID IDIV expr ; .)
    RETURN          reduce using rule 13 (statement -> ID IDIV expr ; .)
    PRINT           reduce using rule 13 (statement -> ID IDIV expr ; .)
    $end            reduce using rule 13 (statement -> ID IDIV expr ; .)
    }               reduce using rule 13 (statement -> ID IDIV expr ; .)
    ELSE            reduce using rule 13 (statement -> ID IDIV expr ; .)


state 77

    (14) statement -> ID IMUL expr ; .
    {               reduce using rule 14 (statement -> ID IMUL expr ; .)
    FOR             reduce using rule 14 (statement -> ID IMUL expr ; .)
    WHILE           reduce using rule 14 (statement -> ID IMUL expr ; .)
    IF              reduce using rule 14 (statement -> ID IMUL expr ; .)
    ID              reduce using rule 14 (statement -> ID IMUL expr ; .)
    CONTINUE        reduce using rule 14 (statement -> ID IMUL expr ; .)
    BREAK           reduce using rule 14 (statement -> ID IMUL expr ; .)
    RETURN          reduce using rule 14 (statement -> ID IMUL expr ; .)
    PRINT           reduce using rule 14 (statement -> ID IMUL expr ; .)
    $end            reduce using rule 14 (statement -> ID IMUL expr ; .)
    }               reduce using rule 14 (statement -> ID IMUL expr ; .)
    ELSE            reduce using rule 14 (statement -> ID IMUL expr ; .)


state 78

    (15) statement -> ID ISUB expr ; .
    {               reduce using rule 15 (statement -> ID ISUB expr ; .)
    FOR             reduce using rule 15 (statement -> ID ISUB expr ; .)
    WHILE           reduce using rule 15 (statement -> ID ISUB expr ; .)
    IF              reduce using rule 15 (statement -> ID ISUB expr ; .)
    ID              reduce using rule 15 (statement -> ID ISUB expr ; .)
    CONTINUE        reduce using rule 15 (statement -> ID ISUB expr ; .)
    BREAK           reduce using rule 15 (statement -> ID ISUB expr ; .)
    RETURN          reduce using rule 15 (statement -> ID ISUB expr ; .)
    PRINT           reduce using rule 15 (statement -> ID ISUB expr ; .)
    $end            reduce using rule 15 (statement -> ID ISUB expr ; .)
    }               reduce using rule 15 (statement -> ID ISUB expr ; .)
    ELSE            reduce using rule 15 (statement -> ID ISUB expr ; .)


state 79

    (16) statement -> ID IADD expr ; .
    {               reduce using rule 16 (statement -> ID IADD expr ; .)
    FOR             reduce using rule 16 (statement -> ID IADD expr ; .)
    WHILE           reduce using rule 16 (statement -> ID IADD expr ; .)
    IF              reduce using rule 16 (statement -> ID IADD expr ; .)
    ID              reduce using rule 16 (statement -> ID IADD expr ; .)
    CONTINUE        reduce using rule 16 (statement -> ID IADD expr ; .)
    BREAK           reduce using rule 16 (statement -> ID IADD expr ; .)
    RETURN          reduce using rule 16 (statement -> ID IADD expr ; .)
    PRINT           reduce using rule 16 (statement -> ID IADD expr ; .)
    $end            reduce using rule 16 (statement -> ID IADD expr ; .)
    }               reduce using rule 16 (statement -> ID IADD expr ; .)
    ELSE            reduce using rule 16 (statement -> ID IADD expr ; .)


state 80

    (17) statement -> ID = expr ; .
    {               reduce using rule 17 (statement -> ID = expr ; .)
    FOR             reduce using rule 17 (statement -> ID = expr ; .)
    WHILE           reduce using rule 17 (statement -> ID = expr ; .)
    IF              reduce using rule 17 (statement -> ID = expr ; .)
    ID              reduce using rule 17 (statement -> ID = expr ; .)
    CONTINUE        reduce using rule 17 (statement -> ID = expr ; .)
    BREAK           reduce using rule 17 (statement -> ID = expr ; .)
    RETURN          reduce using rule 17 (statement -> ID = expr ; .)
    PRINT           reduce using rule 17 (statement -> ID = expr ; .)
    $end            reduce using rule 17 (statement -> ID = expr ; .)
    }               reduce using rule 17 (statement -> ID = expr ; .)
    ELSE            reduce using rule 17 (statement -> ID = expr ; .)


state 81

    (5) statement -> WHILE ( expr ) . statement
    (3) statement -> . { statementseq }
    (4) statement -> . FOR ID = expr : expr statement
    (5) statement -> . WHILE ( expr ) statement
    (6) statement -> . IF ( expr ) statement ELSE statement
    (7) statement -> . IF ( expr ) statement
    (8) statement -> . ID [ exprseq ] IDIV expr ;
    (9) statement -> . ID [ exprseq ] IMUL expr ;
    (10) statement -> . ID [ exprseq ] ISUB expr ;
    (11) statement -> . ID [ exprseq ] IADD expr ;
    (12) statement -> . ID [ exprseq ] = expr ;
    (13) statement -> . ID IDIV expr ;
    (14) statement -> . ID IMUL expr ;
    (15) statement -> . ID ISUB expr ;
    (16) statement -> . ID IADD expr ;
    (17) statement -> . ID = expr ;
    (18) statement -> . CONTINUE ;
    (19) statement -> . BREAK ;
    (20) statement -> . RETURN exprseq ;
    (21) statement -> . PRINT exprseq ;
    {               shift and go to state 3
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 7
    ID              shift and go to state 5
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    RETURN          shift and go to state 10
    PRINT           shift and go to state 11

    statement                      shift and go to state 110

state 82

    (6) statement -> IF ( expr ) . statement ELSE statement
    (7) statement -> IF ( expr ) . statement
    (3) statement -> . { statementseq }
    (4) statement -> . FOR ID = expr : expr statement
    (5) statement -> . WHILE ( expr ) statement
    (6) statement -> . IF ( expr ) statement ELSE statement
    (7) statement -> . IF ( expr ) statement
    (8) statement -> . ID [ exprseq ] IDIV expr ;
    (9) statement -> . ID [ exprseq ] IMUL expr ;
    (10) statement -> . ID [ exprseq ] ISUB expr ;
    (11) statement -> . ID [ exprseq ] IADD expr ;
    (12) statement -> . ID [ exprseq ] = expr ;
    (13) statement -> . ID IDIV expr ;
    (14) statement -> . ID IMUL expr ;
    (15) statement -> . ID ISUB expr ;
    (16) statement -> . ID IADD expr ;
    (17) statement -> . ID = expr ;
    (18) statement -> . CONTINUE ;
    (19) statement -> . BREAK ;
    (20) statement -> . RETURN exprseq ;
    (21) statement -> . PRINT exprseq ;
    {               shift and go to state 3
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 7
    ID              shift and go to state 5
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    RETURN          shift and go to state 10
    PRINT           shift and go to state 11

    statement                      shift and go to state 111

state 83

    (48) exprseq -> exprseq , expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               reduce using rule 48 (exprseq -> exprseq , expr .)
    ,               reduce using rule 48 (exprseq -> exprseq , expr .)
    ]               reduce using rule 48 (exprseq -> exprseq , expr .)
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 84

    (23) expr -> expr [ exprseq . ]
    (48) exprseq -> exprseq . , expr
    ]               shift and go to state 112
    ,               shift and go to state 50


state 85

    (32) expr -> expr LE expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 32 (expr -> expr LE expr .)
    LE              reduce using rule 32 (expr -> expr LE expr .)
    LT              reduce using rule 32 (expr -> expr LE expr .)
    GE              reduce using rule 32 (expr -> expr LE expr .)
    GT              reduce using rule 32 (expr -> expr LE expr .)
    NE              reduce using rule 32 (expr -> expr LE expr .)
    EQ              reduce using rule 32 (expr -> expr LE expr .)
    ;               reduce using rule 32 (expr -> expr LE expr .)
    ,               reduce using rule 32 (expr -> expr LE expr .)
    ]               reduce using rule 32 (expr -> expr LE expr .)
    )               reduce using rule 32 (expr -> expr LE expr .)
    :               reduce using rule 32 (expr -> expr LE expr .)
    {               reduce using rule 32 (expr -> expr LE expr .)
    FOR             reduce using rule 32 (expr -> expr LE expr .)
    WHILE           reduce using rule 32 (expr -> expr LE expr .)
    IF              reduce using rule 32 (expr -> expr LE expr .)
    ID              reduce using rule 32 (expr -> expr LE expr .)
    CONTINUE        reduce using rule 32 (expr -> expr LE expr .)
    BREAK           reduce using rule 32 (expr -> expr LE expr .)
    RETURN          reduce using rule 32 (expr -> expr LE expr .)
    PRINT           reduce using rule 32 (expr -> expr LE expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 86

    (33) expr -> expr LT expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 33 (expr -> expr LT expr .)
    LE              reduce using rule 33 (expr -> expr LT expr .)
    LT              reduce using rule 33 (expr -> expr LT expr .)
    GE              reduce using rule 33 (expr -> expr LT expr .)
    GT              reduce using rule 33 (expr -> expr LT expr .)
    NE              reduce using rule 33 (expr -> expr LT expr .)
    EQ              reduce using rule 33 (expr -> expr LT expr .)
    ;               reduce using rule 33 (expr -> expr LT expr .)
    ,               reduce using rule 33 (expr -> expr LT expr .)
    ]               reduce using rule 33 (expr -> expr LT expr .)
    )               reduce using rule 33 (expr -> expr LT expr .)
    :               reduce using rule 33 (expr -> expr LT expr .)
    {               reduce using rule 33 (expr -> expr LT expr .)
    FOR             reduce using rule 33 (expr -> expr LT expr .)
    WHILE           reduce using rule 33 (expr -> expr LT expr .)
    IF              reduce using rule 33 (expr -> expr LT expr .)
    ID              reduce using rule 33 (expr -> expr LT expr .)
    CONTINUE        reduce using rule 33 (expr -> expr LT expr .)
    BREAK           reduce using rule 33 (expr -> expr LT expr .)
    RETURN          reduce using rule 33 (expr -> expr LT expr .)
    PRINT           reduce using rule 33 (expr -> expr LT expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 87

    (34) expr -> expr GE expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 34 (expr -> expr GE expr .)
    LE              reduce using rule 34 (expr -> expr GE expr .)
    LT              reduce using rule 34 (expr -> expr GE expr .)
    GE              reduce using rule 34 (expr -> expr GE expr .)
    GT              reduce using rule 34 (expr -> expr GE expr .)
    NE              reduce using rule 34 (expr -> expr GE expr .)
    EQ              reduce using rule 34 (expr -> expr GE expr .)
    ;               reduce using rule 34 (expr -> expr GE expr .)
    ,               reduce using rule 34 (expr -> expr GE expr .)
    ]               reduce using rule 34 (expr -> expr GE expr .)
    )               reduce using rule 34 (expr -> expr GE expr .)
    :               reduce using rule 34 (expr -> expr GE expr .)
    {               reduce using rule 34 (expr -> expr GE expr .)
    FOR             reduce using rule 34 (expr -> expr GE expr .)
    WHILE           reduce using rule 34 (expr -> expr GE expr .)
    IF              reduce using rule 34 (expr -> expr GE expr .)
    ID              reduce using rule 34 (expr -> expr GE expr .)
    CONTINUE        reduce using rule 34 (expr -> expr GE expr .)
    BREAK           reduce using rule 34 (expr -> expr GE expr .)
    RETURN          reduce using rule 34 (expr -> expr GE expr .)
    PRINT           reduce using rule 34 (expr -> expr GE expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 88

    (35) expr -> expr GT expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 35 (expr -> expr GT expr .)
    LE              reduce using rule 35 (expr -> expr GT expr .)
    LT              reduce using rule 35 (expr -> expr GT expr .)
    GE              reduce using rule 35 (expr -> expr GT expr .)
    GT              reduce using rule 35 (expr -> expr GT expr .)
    NE              reduce using rule 35 (expr -> expr GT expr .)
    EQ              reduce using rule 35 (expr -> expr GT expr .)
    ;               reduce using rule 35 (expr -> expr GT expr .)
    ,               reduce using rule 35 (expr -> expr GT expr .)
    ]               reduce using rule 35 (expr -> expr GT expr .)
    )               reduce using rule 35 (expr -> expr GT expr .)
    :               reduce using rule 35 (expr -> expr GT expr .)
    {               reduce using rule 35 (expr -> expr GT expr .)
    FOR             reduce using rule 35 (expr -> expr GT expr .)
    WHILE           reduce using rule 35 (expr -> expr GT expr .)
    IF              reduce using rule 35 (expr -> expr GT expr .)
    ID              reduce using rule 35 (expr -> expr GT expr .)
    CONTINUE        reduce using rule 35 (expr -> expr GT expr .)
    BREAK           reduce using rule 35 (expr -> expr GT expr .)
    RETURN          reduce using rule 35 (expr -> expr GT expr .)
    PRINT           reduce using rule 35 (expr -> expr GT expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 89

    (36) expr -> expr NE expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 36 (expr -> expr NE expr .)
    LE              reduce using rule 36 (expr -> expr NE expr .)
    LT              reduce using rule 36 (expr -> expr NE expr .)
    GE              reduce using rule 36 (expr -> expr NE expr .)
    GT              reduce using rule 36 (expr -> expr NE expr .)
    NE              reduce using rule 36 (expr -> expr NE expr .)
    EQ              reduce using rule 36 (expr -> expr NE expr .)
    ;               reduce using rule 36 (expr -> expr NE expr .)
    ,               reduce using rule 36 (expr -> expr NE expr .)
    ]               reduce using rule 36 (expr -> expr NE expr .)
    )               reduce using rule 36 (expr -> expr NE expr .)
    :               reduce using rule 36 (expr -> expr NE expr .)
    {               reduce using rule 36 (expr -> expr NE expr .)
    FOR             reduce using rule 36 (expr -> expr NE expr .)
    WHILE           reduce using rule 36 (expr -> expr NE expr .)
    IF              reduce using rule 36 (expr -> expr NE expr .)
    ID              reduce using rule 36 (expr -> expr NE expr .)
    CONTINUE        reduce using rule 36 (expr -> expr NE expr .)
    BREAK           reduce using rule 36 (expr -> expr NE expr .)
    RETURN          reduce using rule 36 (expr -> expr NE expr .)
    PRINT           reduce using rule 36 (expr -> expr NE expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 90

    (37) expr -> expr EQ expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 37 (expr -> expr EQ expr .)
    LE              reduce using rule 37 (expr -> expr EQ expr .)
    LT              reduce using rule 37 (expr -> expr EQ expr .)
    GE              reduce using rule 37 (expr -> expr EQ expr .)
    GT              reduce using rule 37 (expr -> expr EQ expr .)
    NE              reduce using rule 37 (expr -> expr EQ expr .)
    EQ              reduce using rule 37 (expr -> expr EQ expr .)
    ;               reduce using rule 37 (expr -> expr EQ expr .)
    ,               reduce using rule 37 (expr -> expr EQ expr .)
    ]               reduce using rule 37 (expr -> expr EQ expr .)
    )               reduce using rule 37 (expr -> expr EQ expr .)
    :               reduce using rule 37 (expr -> expr EQ expr .)
    {               reduce using rule 37 (expr -> expr EQ expr .)
    FOR             reduce using rule 37 (expr -> expr EQ expr .)
    WHILE           reduce using rule 37 (expr -> expr EQ expr .)
    IF              reduce using rule 37 (expr -> expr EQ expr .)
    ID              reduce using rule 37 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 37 (expr -> expr EQ expr .)
    BREAK           reduce using rule 37 (expr -> expr EQ expr .)
    RETURN          reduce using rule 37 (expr -> expr EQ expr .)
    PRINT           reduce using rule 37 (expr -> expr EQ expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 91

    (38) expr -> expr DDIV expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 38 (expr -> expr DDIV expr .)
    LE              reduce using rule 38 (expr -> expr DDIV expr .)
    LT              reduce using rule 38 (expr -> expr DDIV expr .)
    GE              reduce using rule 38 (expr -> expr DDIV expr .)
    GT              reduce using rule 38 (expr -> expr DDIV expr .)
    NE              reduce using rule 38 (expr -> expr DDIV expr .)
    EQ              reduce using rule 38 (expr -> expr DDIV expr .)
    DDIV            reduce using rule 38 (expr -> expr DDIV expr .)
    DMUL            reduce using rule 38 (expr -> expr DDIV expr .)
    DSUB            reduce using rule 38 (expr -> expr DDIV expr .)
    DADD            reduce using rule 38 (expr -> expr DDIV expr .)
    DIV             reduce using rule 38 (expr -> expr DDIV expr .)
    MUL             reduce using rule 38 (expr -> expr DDIV expr .)
    SUB             reduce using rule 38 (expr -> expr DDIV expr .)
    ADD             reduce using rule 38 (expr -> expr DDIV expr .)
    ;               reduce using rule 38 (expr -> expr DDIV expr .)
    ,               reduce using rule 38 (expr -> expr DDIV expr .)
    ]               reduce using rule 38 (expr -> expr DDIV expr .)
    )               reduce using rule 38 (expr -> expr DDIV expr .)
    :               reduce using rule 38 (expr -> expr DDIV expr .)
    {               reduce using rule 38 (expr -> expr DDIV expr .)
    FOR             reduce using rule 38 (expr -> expr DDIV expr .)
    WHILE           reduce using rule 38 (expr -> expr DDIV expr .)
    IF              reduce using rule 38 (expr -> expr DDIV expr .)
    ID              reduce using rule 38 (expr -> expr DDIV expr .)
    CONTINUE        reduce using rule 38 (expr -> expr DDIV expr .)
    BREAK           reduce using rule 38 (expr -> expr DDIV expr .)
    RETURN          reduce using rule 38 (expr -> expr DDIV expr .)
    PRINT           reduce using rule 38 (expr -> expr DDIV expr .)
    '               shift and go to state 66


state 92

    (39) expr -> expr DMUL expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 39 (expr -> expr DMUL expr .)
    LE              reduce using rule 39 (expr -> expr DMUL expr .)
    LT              reduce using rule 39 (expr -> expr DMUL expr .)
    GE              reduce using rule 39 (expr -> expr DMUL expr .)
    GT              reduce using rule 39 (expr -> expr DMUL expr .)
    NE              reduce using rule 39 (expr -> expr DMUL expr .)
    EQ              reduce using rule 39 (expr -> expr DMUL expr .)
    DDIV            reduce using rule 39 (expr -> expr DMUL expr .)
    DMUL            reduce using rule 39 (expr -> expr DMUL expr .)
    DSUB            reduce using rule 39 (expr -> expr DMUL expr .)
    DADD            reduce using rule 39 (expr -> expr DMUL expr .)
    DIV             reduce using rule 39 (expr -> expr DMUL expr .)
    MUL             reduce using rule 39 (expr -> expr DMUL expr .)
    SUB             reduce using rule 39 (expr -> expr DMUL expr .)
    ADD             reduce using rule 39 (expr -> expr DMUL expr .)
    ;               reduce using rule 39 (expr -> expr DMUL expr .)
    ,               reduce using rule 39 (expr -> expr DMUL expr .)
    ]               reduce using rule 39 (expr -> expr DMUL expr .)
    )               reduce using rule 39 (expr -> expr DMUL expr .)
    :               reduce using rule 39 (expr -> expr DMUL expr .)
    {               reduce using rule 39 (expr -> expr DMUL expr .)
    FOR             reduce using rule 39 (expr -> expr DMUL expr .)
    WHILE           reduce using rule 39 (expr -> expr DMUL expr .)
    IF              reduce using rule 39 (expr -> expr DMUL expr .)
    ID              reduce using rule 39 (expr -> expr DMUL expr .)
    CONTINUE        reduce using rule 39 (expr -> expr DMUL expr .)
    BREAK           reduce using rule 39 (expr -> expr DMUL expr .)
    RETURN          reduce using rule 39 (expr -> expr DMUL expr .)
    PRINT           reduce using rule 39 (expr -> expr DMUL expr .)
    '               shift and go to state 66


state 93

    (40) expr -> expr DSUB expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 40 (expr -> expr DSUB expr .)
    LE              reduce using rule 40 (expr -> expr DSUB expr .)
    LT              reduce using rule 40 (expr -> expr DSUB expr .)
    GE              reduce using rule 40 (expr -> expr DSUB expr .)
    GT              reduce using rule 40 (expr -> expr DSUB expr .)
    NE              reduce using rule 40 (expr -> expr DSUB expr .)
    EQ              reduce using rule 40 (expr -> expr DSUB expr .)
    DSUB            reduce using rule 40 (expr -> expr DSUB expr .)
    DADD            reduce using rule 40 (expr -> expr DSUB expr .)
    SUB             reduce using rule 40 (expr -> expr DSUB expr .)
    ADD             reduce using rule 40 (expr -> expr DSUB expr .)
    ;               reduce using rule 40 (expr -> expr DSUB expr .)
    ,               reduce using rule 40 (expr -> expr DSUB expr .)
    ]               reduce using rule 40 (expr -> expr DSUB expr .)
    )               reduce using rule 40 (expr -> expr DSUB expr .)
    :               reduce using rule 40 (expr -> expr DSUB expr .)
    {               reduce using rule 40 (expr -> expr DSUB expr .)
    FOR             reduce using rule 40 (expr -> expr DSUB expr .)
    WHILE           reduce using rule 40 (expr -> expr DSUB expr .)
    IF              reduce using rule 40 (expr -> expr DSUB expr .)
    ID              reduce using rule 40 (expr -> expr DSUB expr .)
    CONTINUE        reduce using rule 40 (expr -> expr DSUB expr .)
    BREAK           reduce using rule 40 (expr -> expr DSUB expr .)
    RETURN          reduce using rule 40 (expr -> expr DSUB expr .)
    PRINT           reduce using rule 40 (expr -> expr DSUB expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    '               shift and go to state 66


state 94

    (41) expr -> expr DADD expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 41 (expr -> expr DADD expr .)
    LE              reduce using rule 41 (expr -> expr DADD expr .)
    LT              reduce using rule 41 (expr -> expr DADD expr .)
    GE              reduce using rule 41 (expr -> expr DADD expr .)
    GT              reduce using rule 41 (expr -> expr DADD expr .)
    NE              reduce using rule 41 (expr -> expr DADD expr .)
    EQ              reduce using rule 41 (expr -> expr DADD expr .)
    DSUB            reduce using rule 41 (expr -> expr DADD expr .)
    DADD            reduce using rule 41 (expr -> expr DADD expr .)
    SUB             reduce using rule 41 (expr -> expr DADD expr .)
    ADD             reduce using rule 41 (expr -> expr DADD expr .)
    ;               reduce using rule 41 (expr -> expr DADD expr .)
    ,               reduce using rule 41 (expr -> expr DADD expr .)
    ]               reduce using rule 41 (expr -> expr DADD expr .)
    )               reduce using rule 41 (expr -> expr DADD expr .)
    :               reduce using rule 41 (expr -> expr DADD expr .)
    {               reduce using rule 41 (expr -> expr DADD expr .)
    FOR             reduce using rule 41 (expr -> expr DADD expr .)
    WHILE           reduce using rule 41 (expr -> expr DADD expr .)
    IF              reduce using rule 41 (expr -> expr DADD expr .)
    ID              reduce using rule 41 (expr -> expr DADD expr .)
    CONTINUE        reduce using rule 41 (expr -> expr DADD expr .)
    BREAK           reduce using rule 41 (expr -> expr DADD expr .)
    RETURN          reduce using rule 41 (expr -> expr DADD expr .)
    PRINT           reduce using rule 41 (expr -> expr DADD expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    '               shift and go to state 66


state 95

    (42) expr -> expr DIV expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 42 (expr -> expr DIV expr .)
    LE              reduce using rule 42 (expr -> expr DIV expr .)
    LT              reduce using rule 42 (expr -> expr DIV expr .)
    GE              reduce using rule 42 (expr -> expr DIV expr .)
    GT              reduce using rule 42 (expr -> expr DIV expr .)
    NE              reduce using rule 42 (expr -> expr DIV expr .)
    EQ              reduce using rule 42 (expr -> expr DIV expr .)
    DDIV            reduce using rule 42 (expr -> expr DIV expr .)
    DMUL            reduce using rule 42 (expr -> expr DIV expr .)
    DSUB            reduce using rule 42 (expr -> expr DIV expr .)
    DADD            reduce using rule 42 (expr -> expr DIV expr .)
    DIV             reduce using rule 42 (expr -> expr DIV expr .)
    MUL             reduce using rule 42 (expr -> expr DIV expr .)
    SUB             reduce using rule 42 (expr -> expr DIV expr .)
    ADD             reduce using rule 42 (expr -> expr DIV expr .)
    ;               reduce using rule 42 (expr -> expr DIV expr .)
    ,               reduce using rule 42 (expr -> expr DIV expr .)
    ]               reduce using rule 42 (expr -> expr DIV expr .)
    )               reduce using rule 42 (expr -> expr DIV expr .)
    :               reduce using rule 42 (expr -> expr DIV expr .)
    {               reduce using rule 42 (expr -> expr DIV expr .)
    FOR             reduce using rule 42 (expr -> expr DIV expr .)
    WHILE           reduce using rule 42 (expr -> expr DIV expr .)
    IF              reduce using rule 42 (expr -> expr DIV expr .)
    ID              reduce using rule 42 (expr -> expr DIV expr .)
    CONTINUE        reduce using rule 42 (expr -> expr DIV expr .)
    BREAK           reduce using rule 42 (expr -> expr DIV expr .)
    RETURN          reduce using rule 42 (expr -> expr DIV expr .)
    PRINT           reduce using rule 42 (expr -> expr DIV expr .)
    '               shift and go to state 66


state 96

    (43) expr -> expr MUL expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 43 (expr -> expr MUL expr .)
    LE              reduce using rule 43 (expr -> expr MUL expr .)
    LT              reduce using rule 43 (expr -> expr MUL expr .)
    GE              reduce using rule 43 (expr -> expr MUL expr .)
    GT              reduce using rule 43 (expr -> expr MUL expr .)
    NE              reduce using rule 43 (expr -> expr MUL expr .)
    EQ              reduce using rule 43 (expr -> expr MUL expr .)
    DDIV            reduce using rule 43 (expr -> expr MUL expr .)
    DMUL            reduce using rule 43 (expr -> expr MUL expr .)
    DSUB            reduce using rule 43 (expr -> expr MUL expr .)
    DADD            reduce using rule 43 (expr -> expr MUL expr .)
    DIV             reduce using rule 43 (expr -> expr MUL expr .)
    MUL             reduce using rule 43 (expr -> expr MUL expr .)
    SUB             reduce using rule 43 (expr -> expr MUL expr .)
    ADD             reduce using rule 43 (expr -> expr MUL expr .)
    ;               reduce using rule 43 (expr -> expr MUL expr .)
    ,               reduce using rule 43 (expr -> expr MUL expr .)
    ]               reduce using rule 43 (expr -> expr MUL expr .)
    )               reduce using rule 43 (expr -> expr MUL expr .)
    :               reduce using rule 43 (expr -> expr MUL expr .)
    {               reduce using rule 43 (expr -> expr MUL expr .)
    FOR             reduce using rule 43 (expr -> expr MUL expr .)
    WHILE           reduce using rule 43 (expr -> expr MUL expr .)
    IF              reduce using rule 43 (expr -> expr MUL expr .)
    ID              reduce using rule 43 (expr -> expr MUL expr .)
    CONTINUE        reduce using rule 43 (expr -> expr MUL expr .)
    BREAK           reduce using rule 43 (expr -> expr MUL expr .)
    RETURN          reduce using rule 43 (expr -> expr MUL expr .)
    PRINT           reduce using rule 43 (expr -> expr MUL expr .)
    '               shift and go to state 66


state 97

    (44) expr -> expr SUB expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 44 (expr -> expr SUB expr .)
    LE              reduce using rule 44 (expr -> expr SUB expr .)
    LT              reduce using rule 44 (expr -> expr SUB expr .)
    GE              reduce using rule 44 (expr -> expr SUB expr .)
    GT              reduce using rule 44 (expr -> expr SUB expr .)
    NE              reduce using rule 44 (expr -> expr SUB expr .)
    EQ              reduce using rule 44 (expr -> expr SUB expr .)
    DSUB            reduce using rule 44 (expr -> expr SUB expr .)
    DADD            reduce using rule 44 (expr -> expr SUB expr .)
    SUB             reduce using rule 44 (expr -> expr SUB expr .)
    ADD             reduce using rule 44 (expr -> expr SUB expr .)
    ;               reduce using rule 44 (expr -> expr SUB expr .)
    ,               reduce using rule 44 (expr -> expr SUB expr .)
    ]               reduce using rule 44 (expr -> expr SUB expr .)
    )               reduce using rule 44 (expr -> expr SUB expr .)
    :               reduce using rule 44 (expr -> expr SUB expr .)
    {               reduce using rule 44 (expr -> expr SUB expr .)
    FOR             reduce using rule 44 (expr -> expr SUB expr .)
    WHILE           reduce using rule 44 (expr -> expr SUB expr .)
    IF              reduce using rule 44 (expr -> expr SUB expr .)
    ID              reduce using rule 44 (expr -> expr SUB expr .)
    CONTINUE        reduce using rule 44 (expr -> expr SUB expr .)
    BREAK           reduce using rule 44 (expr -> expr SUB expr .)
    RETURN          reduce using rule 44 (expr -> expr SUB expr .)
    PRINT           reduce using rule 44 (expr -> expr SUB expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    '               shift and go to state 66


state 98

    (45) expr -> expr ADD expr .
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    [               reduce using rule 45 (expr -> expr ADD expr .)
    LE              reduce using rule 45 (expr -> expr ADD expr .)
    LT              reduce using rule 45 (expr -> expr ADD expr .)
    GE              reduce using rule 45 (expr -> expr ADD expr .)
    GT              reduce using rule 45 (expr -> expr ADD expr .)
    NE              reduce using rule 45 (expr -> expr ADD expr .)
    EQ              reduce using rule 45 (expr -> expr ADD expr .)
    DSUB            reduce using rule 45 (expr -> expr ADD expr .)
    DADD            reduce using rule 45 (expr -> expr ADD expr .)
    SUB             reduce using rule 45 (expr -> expr ADD expr .)
    ADD             reduce using rule 45 (expr -> expr ADD expr .)
    ;               reduce using rule 45 (expr -> expr ADD expr .)
    ,               reduce using rule 45 (expr -> expr ADD expr .)
    ]               reduce using rule 45 (expr -> expr ADD expr .)
    )               reduce using rule 45 (expr -> expr ADD expr .)
    :               reduce using rule 45 (expr -> expr ADD expr .)
    {               reduce using rule 45 (expr -> expr ADD expr .)
    FOR             reduce using rule 45 (expr -> expr ADD expr .)
    WHILE           reduce using rule 45 (expr -> expr ADD expr .)
    IF              reduce using rule 45 (expr -> expr ADD expr .)
    ID              reduce using rule 45 (expr -> expr ADD expr .)
    CONTINUE        reduce using rule 45 (expr -> expr ADD expr .)
    BREAK           reduce using rule 45 (expr -> expr ADD expr .)
    RETURN          reduce using rule 45 (expr -> expr ADD expr .)
    PRINT           reduce using rule 45 (expr -> expr ADD expr .)
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    '               shift and go to state 66


state 99

    (50) array -> [ exprseq ] .
    [               reduce using rule 50 (array -> [ exprseq ] .)
    LE              reduce using rule 50 (array -> [ exprseq ] .)
    LT              reduce using rule 50 (array -> [ exprseq ] .)
    GE              reduce using rule 50 (array -> [ exprseq ] .)
    GT              reduce using rule 50 (array -> [ exprseq ] .)
    NE              reduce using rule 50 (array -> [ exprseq ] .)
    EQ              reduce using rule 50 (array -> [ exprseq ] .)
    DDIV            reduce using rule 50 (array -> [ exprseq ] .)
    DMUL            reduce using rule 50 (array -> [ exprseq ] .)
    DSUB            reduce using rule 50 (array -> [ exprseq ] .)
    DADD            reduce using rule 50 (array -> [ exprseq ] .)
    DIV             reduce using rule 50 (array -> [ exprseq ] .)
    MUL             reduce using rule 50 (array -> [ exprseq ] .)
    SUB             reduce using rule 50 (array -> [ exprseq ] .)
    ADD             reduce using rule 50 (array -> [ exprseq ] .)
    '               reduce using rule 50 (array -> [ exprseq ] .)
    ;               reduce using rule 50 (array -> [ exprseq ] .)
    ,               reduce using rule 50 (array -> [ exprseq ] .)
    ]               reduce using rule 50 (array -> [ exprseq ] .)
    )               reduce using rule 50 (array -> [ exprseq ] .)
    :               reduce using rule 50 (array -> [ exprseq ] .)
    {               reduce using rule 50 (array -> [ exprseq ] .)
    FOR             reduce using rule 50 (array -> [ exprseq ] .)
    WHILE           reduce using rule 50 (array -> [ exprseq ] .)
    IF              reduce using rule 50 (array -> [ exprseq ] .)
    ID              reduce using rule 50 (array -> [ exprseq ] .)
    CONTINUE        reduce using rule 50 (array -> [ exprseq ] .)
    BREAK           reduce using rule 50 (array -> [ exprseq ] .)
    RETURN          reduce using rule 50 (array -> [ exprseq ] .)
    PRINT           reduce using rule 50 (array -> [ exprseq ] .)


state 100

    (24) expr -> ZEROS ( expr . )
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    )               shift and go to state 113
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 101

    (31) expr -> ( expr ) .
    [               reduce using rule 31 (expr -> ( expr ) .)
    LE              reduce using rule 31 (expr -> ( expr ) .)
    LT              reduce using rule 31 (expr -> ( expr ) .)
    GE              reduce using rule 31 (expr -> ( expr ) .)
    GT              reduce using rule 31 (expr -> ( expr ) .)
    NE              reduce using rule 31 (expr -> ( expr ) .)
    EQ              reduce using rule 31 (expr -> ( expr ) .)
    DDIV            reduce using rule 31 (expr -> ( expr ) .)
    DMUL            reduce using rule 31 (expr -> ( expr ) .)
    DSUB            reduce using rule 31 (expr -> ( expr ) .)
    DADD            reduce using rule 31 (expr -> ( expr ) .)
    DIV             reduce using rule 31 (expr -> ( expr ) .)
    MUL             reduce using rule 31 (expr -> ( expr ) .)
    SUB             reduce using rule 31 (expr -> ( expr ) .)
    ADD             reduce using rule 31 (expr -> ( expr ) .)
    '               reduce using rule 31 (expr -> ( expr ) .)
    ;               reduce using rule 31 (expr -> ( expr ) .)
    ,               reduce using rule 31 (expr -> ( expr ) .)
    ]               reduce using rule 31 (expr -> ( expr ) .)
    )               reduce using rule 31 (expr -> ( expr ) .)
    :               reduce using rule 31 (expr -> ( expr ) .)
    {               reduce using rule 31 (expr -> ( expr ) .)
    FOR             reduce using rule 31 (expr -> ( expr ) .)
    WHILE           reduce using rule 31 (expr -> ( expr ) .)
    IF              reduce using rule 31 (expr -> ( expr ) .)
    ID              reduce using rule 31 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 31 (expr -> ( expr ) .)
    BREAK           reduce using rule 31 (expr -> ( expr ) .)
    RETURN          reduce using rule 31 (expr -> ( expr ) .)
    PRINT           reduce using rule 31 (expr -> ( expr ) .)


state 102

    (25) expr -> ONES ( expr . )
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    )               shift and go to state 114
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 103

    (26) expr -> EYE ( expr . )
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    )               shift and go to state 115
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 104

    (4) statement -> FOR ID = expr : . expr statement
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 116
    array                          shift and go to state 27

state 105

    (8) statement -> ID [ exprseq ] IDIV . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 117
    array                          shift and go to state 27

state 106

    (9) statement -> ID [ exprseq ] IMUL . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 118
    array                          shift and go to state 27

state 107

    (10) statement -> ID [ exprseq ] ISUB . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 119
    array                          shift and go to state 27

state 108

    (11) statement -> ID [ exprseq ] IADD . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 120
    array                          shift and go to state 27

state 109

    (12) statement -> ID [ exprseq ] = . expr ;
    (22) expr -> . array
    (23) expr -> . expr [ exprseq ]
    (24) expr -> . ZEROS ( expr )
    (25) expr -> . ONES ( expr )
    (26) expr -> . EYE ( expr )
    (27) expr -> . STRING
    (28) expr -> . FLOATNUM
    (29) expr -> . INTNUM
    (30) expr -> . ID
    (31) expr -> . ( expr )
    (32) expr -> . expr LE expr
    (33) expr -> . expr LT expr
    (34) expr -> . expr GE expr
    (35) expr -> . expr GT expr
    (36) expr -> . expr NE expr
    (37) expr -> . expr EQ expr
    (38) expr -> . expr DDIV expr
    (39) expr -> . expr DMUL expr
    (40) expr -> . expr DSUB expr
    (41) expr -> . expr DADD expr
    (42) expr -> . expr DIV expr
    (43) expr -> . expr MUL expr
    (44) expr -> . expr SUB expr
    (45) expr -> . expr ADD expr
    (46) expr -> . expr '
    (47) expr -> . SUB expr
    (50) array -> . [ exprseq ]
    ZEROS           shift and go to state 29
    ONES            shift and go to state 31
    EYE             shift and go to state 32
    STRING          shift and go to state 33
    FLOATNUM        shift and go to state 34
    INTNUM          shift and go to state 35
    ID              shift and go to state 36
    (               shift and go to state 30
    SUB             shift and go to state 37
    [               shift and go to state 28

    expr                           shift and go to state 121
    array                          shift and go to state 27

state 110

    (5) statement -> WHILE ( expr ) statement .
    {               reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    FOR             reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    WHILE           reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    IF              reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    ID              reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    CONTINUE        reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    BREAK           reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    RETURN          reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    PRINT           reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    $end            reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    }               reduce using rule 5 (statement -> WHILE ( expr ) statement .)
    ELSE            reduce using rule 5 (statement -> WHILE ( expr ) statement .)


state 111

    (6) statement -> IF ( expr ) statement . ELSE statement
    (7) statement -> IF ( expr ) statement .
    ELSE            shift and go to state 122
    {               reduce using rule 7 (statement -> IF ( expr ) statement .)
    FOR             reduce using rule 7 (statement -> IF ( expr ) statement .)
    WHILE           reduce using rule 7 (statement -> IF ( expr ) statement .)
    IF              reduce using rule 7 (statement -> IF ( expr ) statement .)
    ID              reduce using rule 7 (statement -> IF ( expr ) statement .)
    CONTINUE        reduce using rule 7 (statement -> IF ( expr ) statement .)
    BREAK           reduce using rule 7 (statement -> IF ( expr ) statement .)
    RETURN          reduce using rule 7 (statement -> IF ( expr ) statement .)
    PRINT           reduce using rule 7 (statement -> IF ( expr ) statement .)
    $end            reduce using rule 7 (statement -> IF ( expr ) statement .)
    }               reduce using rule 7 (statement -> IF ( expr ) statement .)


state 112

    (23) expr -> expr [ exprseq ] .
    [               reduce using rule 23 (expr -> expr [ exprseq ] .)
    LE              reduce using rule 23 (expr -> expr [ exprseq ] .)
    LT              reduce using rule 23 (expr -> expr [ exprseq ] .)
    GE              reduce using rule 23 (expr -> expr [ exprseq ] .)
    GT              reduce using rule 23 (expr -> expr [ exprseq ] .)
    NE              reduce using rule 23 (expr -> expr [ exprseq ] .)
    EQ              reduce using rule 23 (expr -> expr [ exprseq ] .)
    DDIV            reduce using rule 23 (expr -> expr [ exprseq ] .)
    DMUL            reduce using rule 23 (expr -> expr [ exprseq ] .)
    DSUB            reduce using rule 23 (expr -> expr [ exprseq ] .)
    DADD            reduce using rule 23 (expr -> expr [ exprseq ] .)
    DIV             reduce using rule 23 (expr -> expr [ exprseq ] .)
    MUL             reduce using rule 23 (expr -> expr [ exprseq ] .)
    SUB             reduce using rule 23 (expr -> expr [ exprseq ] .)
    ADD             reduce using rule 23 (expr -> expr [ exprseq ] .)
    '               reduce using rule 23 (expr -> expr [ exprseq ] .)
    ;               reduce using rule 23 (expr -> expr [ exprseq ] .)
    ,               reduce using rule 23 (expr -> expr [ exprseq ] .)
    ]               reduce using rule 23 (expr -> expr [ exprseq ] .)
    )               reduce using rule 23 (expr -> expr [ exprseq ] .)
    :               reduce using rule 23 (expr -> expr [ exprseq ] .)
    {               reduce using rule 23 (expr -> expr [ exprseq ] .)
    FOR             reduce using rule 23 (expr -> expr [ exprseq ] .)
    WHILE           reduce using rule 23 (expr -> expr [ exprseq ] .)
    IF              reduce using rule 23 (expr -> expr [ exprseq ] .)
    ID              reduce using rule 23 (expr -> expr [ exprseq ] .)
    CONTINUE        reduce using rule 23 (expr -> expr [ exprseq ] .)
    BREAK           reduce using rule 23 (expr -> expr [ exprseq ] .)
    RETURN          reduce using rule 23 (expr -> expr [ exprseq ] .)
    PRINT           reduce using rule 23 (expr -> expr [ exprseq ] .)


state 113

    (24) expr -> ZEROS ( expr ) .
    [               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    LE              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    LT              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    GE              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    GT              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    NE              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    EQ              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    DDIV            reduce using rule 24 (expr -> ZEROS ( expr ) .)
    DMUL            reduce using rule 24 (expr -> ZEROS ( expr ) .)
    DSUB            reduce using rule 24 (expr -> ZEROS ( expr ) .)
    DADD            reduce using rule 24 (expr -> ZEROS ( expr ) .)
    DIV             reduce using rule 24 (expr -> ZEROS ( expr ) .)
    MUL             reduce using rule 24 (expr -> ZEROS ( expr ) .)
    SUB             reduce using rule 24 (expr -> ZEROS ( expr ) .)
    ADD             reduce using rule 24 (expr -> ZEROS ( expr ) .)
    '               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    ;               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    ,               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    ]               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    )               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    :               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    {               reduce using rule 24 (expr -> ZEROS ( expr ) .)
    FOR             reduce using rule 24 (expr -> ZEROS ( expr ) .)
    WHILE           reduce using rule 24 (expr -> ZEROS ( expr ) .)
    IF              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    ID              reduce using rule 24 (expr -> ZEROS ( expr ) .)
    CONTINUE        reduce using rule 24 (expr -> ZEROS ( expr ) .)
    BREAK           reduce using rule 24 (expr -> ZEROS ( expr ) .)
    RETURN          reduce using rule 24 (expr -> ZEROS ( expr ) .)
    PRINT           reduce using rule 24 (expr -> ZEROS ( expr ) .)


state 114

    (25) expr -> ONES ( expr ) .
    [               reduce using rule 25 (expr -> ONES ( expr ) .)
    LE              reduce using rule 25 (expr -> ONES ( expr ) .)
    LT              reduce using rule 25 (expr -> ONES ( expr ) .)
    GE              reduce using rule 25 (expr -> ONES ( expr ) .)
    GT              reduce using rule 25 (expr -> ONES ( expr ) .)
    NE              reduce using rule 25 (expr -> ONES ( expr ) .)
    EQ              reduce using rule 25 (expr -> ONES ( expr ) .)
    DDIV            reduce using rule 25 (expr -> ONES ( expr ) .)
    DMUL            reduce using rule 25 (expr -> ONES ( expr ) .)
    DSUB            reduce using rule 25 (expr -> ONES ( expr ) .)
    DADD            reduce using rule 25 (expr -> ONES ( expr ) .)
    DIV             reduce using rule 25 (expr -> ONES ( expr ) .)
    MUL             reduce using rule 25 (expr -> ONES ( expr ) .)
    SUB             reduce using rule 25 (expr -> ONES ( expr ) .)
    ADD             reduce using rule 25 (expr -> ONES ( expr ) .)
    '               reduce using rule 25 (expr -> ONES ( expr ) .)
    ;               reduce using rule 25 (expr -> ONES ( expr ) .)
    ,               reduce using rule 25 (expr -> ONES ( expr ) .)
    ]               reduce using rule 25 (expr -> ONES ( expr ) .)
    )               reduce using rule 25 (expr -> ONES ( expr ) .)
    :               reduce using rule 25 (expr -> ONES ( expr ) .)
    {               reduce using rule 25 (expr -> ONES ( expr ) .)
    FOR             reduce using rule 25 (expr -> ONES ( expr ) .)
    WHILE           reduce using rule 25 (expr -> ONES ( expr ) .)
    IF              reduce using rule 25 (expr -> ONES ( expr ) .)
    ID              reduce using rule 25 (expr -> ONES ( expr ) .)
    CONTINUE        reduce using rule 25 (expr -> ONES ( expr ) .)
    BREAK           reduce using rule 25 (expr -> ONES ( expr ) .)
    RETURN          reduce using rule 25 (expr -> ONES ( expr ) .)
    PRINT           reduce using rule 25 (expr -> ONES ( expr ) .)


state 115

    (26) expr -> EYE ( expr ) .
    [               reduce using rule 26 (expr -> EYE ( expr ) .)
    LE              reduce using rule 26 (expr -> EYE ( expr ) .)
    LT              reduce using rule 26 (expr -> EYE ( expr ) .)
    GE              reduce using rule 26 (expr -> EYE ( expr ) .)
    GT              reduce using rule 26 (expr -> EYE ( expr ) .)
    NE              reduce using rule 26 (expr -> EYE ( expr ) .)
    EQ              reduce using rule 26 (expr -> EYE ( expr ) .)
    DDIV            reduce using rule 26 (expr -> EYE ( expr ) .)
    DMUL            reduce using rule 26 (expr -> EYE ( expr ) .)
    DSUB            reduce using rule 26 (expr -> EYE ( expr ) .)
    DADD            reduce using rule 26 (expr -> EYE ( expr ) .)
    DIV             reduce using rule 26 (expr -> EYE ( expr ) .)
    MUL             reduce using rule 26 (expr -> EYE ( expr ) .)
    SUB             reduce using rule 26 (expr -> EYE ( expr ) .)
    ADD             reduce using rule 26 (expr -> EYE ( expr ) .)
    '               reduce using rule 26 (expr -> EYE ( expr ) .)
    ;               reduce using rule 26 (expr -> EYE ( expr ) .)
    ,               reduce using rule 26 (expr -> EYE ( expr ) .)
    ]               reduce using rule 26 (expr -> EYE ( expr ) .)
    )               reduce using rule 26 (expr -> EYE ( expr ) .)
    :               reduce using rule 26 (expr -> EYE ( expr ) .)
    {               reduce using rule 26 (expr -> EYE ( expr ) .)
    FOR             reduce using rule 26 (expr -> EYE ( expr ) .)
    WHILE           reduce using rule 26 (expr -> EYE ( expr ) .)
    IF              reduce using rule 26 (expr -> EYE ( expr ) .)
    ID              reduce using rule 26 (expr -> EYE ( expr ) .)
    CONTINUE        reduce using rule 26 (expr -> EYE ( expr ) .)
    BREAK           reduce using rule 26 (expr -> EYE ( expr ) .)
    RETURN          reduce using rule 26 (expr -> EYE ( expr ) .)
    PRINT           reduce using rule 26 (expr -> EYE ( expr ) .)


state 116

    (4) statement -> FOR ID = expr : expr . statement
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    (3) statement -> . { statementseq }
    (4) statement -> . FOR ID = expr : expr statement
    (5) statement -> . WHILE ( expr ) statement
    (6) statement -> . IF ( expr ) statement ELSE statement
    (7) statement -> . IF ( expr ) statement
    (8) statement -> . ID [ exprseq ] IDIV expr ;
    (9) statement -> . ID [ exprseq ] IMUL expr ;
    (10) statement -> . ID [ exprseq ] ISUB expr ;
    (11) statement -> . ID [ exprseq ] IADD expr ;
    (12) statement -> . ID [ exprseq ] = expr ;
    (13) statement -> . ID IDIV expr ;
    (14) statement -> . ID IMUL expr ;
    (15) statement -> . ID ISUB expr ;
    (16) statement -> . ID IADD expr ;
    (17) statement -> . ID = expr ;
    (18) statement -> . CONTINUE ;
    (19) statement -> . BREAK ;
    (20) statement -> . RETURN exprseq ;
    (21) statement -> . PRINT exprseq ;
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66
    {               shift and go to state 3
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 7
    ID              shift and go to state 5
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    RETURN          shift and go to state 10
    PRINT           shift and go to state 11

    statement                      shift and go to state 123

state 117

    (8) statement -> ID [ exprseq ] IDIV expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 124
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 118

    (9) statement -> ID [ exprseq ] IMUL expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 125
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 119

    (10) statement -> ID [ exprseq ] ISUB expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 126
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 120

    (11) statement -> ID [ exprseq ] IADD expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 127
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 121

    (12) statement -> ID [ exprseq ] = expr . ;
    (23) expr -> expr . [ exprseq ]
    (32) expr -> expr . LE expr
    (33) expr -> expr . LT expr
    (34) expr -> expr . GE expr
    (35) expr -> expr . GT expr
    (36) expr -> expr . NE expr
    (37) expr -> expr . EQ expr
    (38) expr -> expr . DDIV expr
    (39) expr -> expr . DMUL expr
    (40) expr -> expr . DSUB expr
    (41) expr -> expr . DADD expr
    (42) expr -> expr . DIV expr
    (43) expr -> expr . MUL expr
    (44) expr -> expr . SUB expr
    (45) expr -> expr . ADD expr
    (46) expr -> expr . '
    ;               shift and go to state 128
    [               shift and go to state 51
    LE              shift and go to state 52
    LT              shift and go to state 53
    GE              shift and go to state 54
    GT              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    DDIV            shift and go to state 58
    DMUL            shift and go to state 59
    DSUB            shift and go to state 60
    DADD            shift and go to state 61
    DIV             shift and go to state 62
    MUL             shift and go to state 63
    SUB             shift and go to state 64
    ADD             shift and go to state 65
    '               shift and go to state 66


state 122

    (6) statement -> IF ( expr ) statement ELSE . statement
    (3) statement -> . { statementseq }
    (4) statement -> . FOR ID = expr : expr statement
    (5) statement -> . WHILE ( expr ) statement
    (6) statement -> . IF ( expr ) statement ELSE statement
    (7) statement -> . IF ( expr ) statement
    (8) statement -> . ID [ exprseq ] IDIV expr ;
    (9) statement -> . ID [ exprseq ] IMUL expr ;
    (10) statement -> . ID [ exprseq ] ISUB expr ;
    (11) statement -> . ID [ exprseq ] IADD expr ;
    (12) statement -> . ID [ exprseq ] = expr ;
    (13) statement -> . ID IDIV expr ;
    (14) statement -> . ID IMUL expr ;
    (15) statement -> . ID ISUB expr ;
    (16) statement -> . ID IADD expr ;
    (17) statement -> . ID = expr ;
    (18) statement -> . CONTINUE ;
    (19) statement -> . BREAK ;
    (20) statement -> . RETURN exprseq ;
    (21) statement -> . PRINT exprseq ;
    {               shift and go to state 3
    FOR             shift and go to state 4
    WHILE           shift and go to state 6
    IF              shift and go to state 7
    ID              shift and go to state 5
    CONTINUE        shift and go to state 8
    BREAK           shift and go to state 9
    RETURN          shift and go to state 10
    PRINT           shift and go to state 11

    statement                      shift and go to state 129

state 123

    (4) statement -> FOR ID = expr : expr statement .
    {               reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    FOR             reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    WHILE           reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    IF              reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    ID              reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    CONTINUE        reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    BREAK           reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    RETURN          reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    PRINT           reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    $end            reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    }               reduce using rule 4 (statement -> FOR ID = expr : expr statement .)
    ELSE            reduce using rule 4 (statement -> FOR ID = expr : expr statement .)


state 124

    (8) statement -> ID [ exprseq ] IDIV expr ; .
    {               reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    FOR             reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    WHILE           reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    IF              reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    ID              reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    CONTINUE        reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    BREAK           reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    RETURN          reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    PRINT           reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    $end            reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    }               reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)
    ELSE            reduce using rule 8 (statement -> ID [ exprseq ] IDIV expr ; .)


state 125

    (9) statement -> ID [ exprseq ] IMUL expr ; .
    {               reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    FOR             reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    WHILE           reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    IF              reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    ID              reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    CONTINUE        reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    BREAK           reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    RETURN          reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    PRINT           reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    $end            reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    }               reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)
    ELSE            reduce using rule 9 (statement -> ID [ exprseq ] IMUL expr ; .)


state 126

    (10) statement -> ID [ exprseq ] ISUB expr ; .
    {               reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    FOR             reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    WHILE           reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    IF              reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    ID              reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    CONTINUE        reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    BREAK           reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    RETURN          reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    PRINT           reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    $end            reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    }               reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)
    ELSE            reduce using rule 10 (statement -> ID [ exprseq ] ISUB expr ; .)


state 127

    (11) statement -> ID [ exprseq ] IADD expr ; .
    {               reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    FOR             reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    WHILE           reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    IF              reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    ID              reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    CONTINUE        reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    BREAK           reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    RETURN          reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    PRINT           reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    $end            reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    }               reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)
    ELSE            reduce using rule 11 (statement -> ID [ exprseq ] IADD expr ; .)


state 128

    (12) statement -> ID [ exprseq ] = expr ; .
    {               reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    FOR             reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    WHILE           reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    IF              reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    ID              reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    CONTINUE        reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    BREAK           reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    RETURN          reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    PRINT           reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    $end            reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    }               reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)
    ELSE            reduce using rule 12 (statement -> ID [ exprseq ] = expr ; .)


state 129

    (6) statement -> IF ( expr ) statement ELSE statement .
    {               reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    FOR             reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    WHILE           reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    IF              reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    ID              reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    CONTINUE        reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    BREAK           reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    RETURN          reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    PRINT           reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    $end            reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    }               reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
    ELSE            reduce using rule 6 (statement -> IF ( expr ) statement ELSE statement .)
